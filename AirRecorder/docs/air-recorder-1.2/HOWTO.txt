AirRecorder
-----------

A Java based tool that will run several common CLI commands for checking
controller, AP, and wireless device health. 


1. SUPPORTED PLATFORMS
----------------------

AirRecorder is based on Java Platform, Standard Edition and therefore should run
on any operating system that supports a Java Platform, Standard Edition 
version 6 or later.
In particular, AirRecorder is known to work on Windows, Linux/Unix and MacOS.

AirRecorder supports ArubaOS, Instant VC (IAP) and MeshOS (MSR).


2. PREREQUISITES
----------------

A Java Platform, Standard Edition version 6 or later must be installed to run
AirRecorder.

To check if Java is installed properly:
*** Windows: open a command (DOS) window and type: java -version
*** Linux/Unix: open a Shell terminal and type: java -version

You should get an output similar to (ensure that the version is at least 1.6):
 java version "1.6.0_24"
 Java(TM) SE Runtime Environment (build 1.6.0_24-b07)
 Java HotSpot(TM) 64-Bit Server VM (build 19.1-b02, mixed mode)

If Java is not installed, please download and install it from:
http://java.com/en/download/index.jsp

!!!NOTE!!!: the Java Virtual Machine (JVM) bit size (32-bit versus 64-bit) should
match the bit size of the underlying operating system. As a rule of thumb, use
following rule:

----------------------------
|OS bit-size | JVM bit-size|
|--------------------------|
| 32         | 32          |
| 64         | 64          |
----------------------------

For example on Windows systems, if you get following error message:
'java' is not recognized as an internal or external command, operable program or batch file.
most likely the wrong JVM is installed for the OS.


3. INSTALLATION
---------------

Please unpack the AirRecorder distribution ZIP file to a directory or folder of 
choice. On successful unpacking, you should at least find following files:
 AirRecorder-<version>-release.jar
 CHANGES.txt
 EULA.pdf
 HOWTO.txt
 LICENSE.txt
 README.txt
 samples

Please note that "samples" is a folder that contains sample files.

Next, please open a terminal window in the directory/folder:
*** Windows: open a command (DOS) window and "cd" to the directory
*** Linux/Unix: open a Shell terminal and "cd" to the directory

Next, please type: java -jar AirRecorder-<version>-release.jar
You should get an output that starts with:
 AirRecorder (c)2011-2012 Thomas Bastian, Aruba Networks
 usage: AirRecorder [options] <controllerip>
 ...


4. FIRST USE
------------

AirRecorder records the output of CLI commands in a file. By default, the list 
of commands is read from a file named "commands" or "commands.txt". Please go 
ahead and create a file named "commands.txt" in the distribution directory. 
Enter a single line into the file:
0,show ap active
and save the file.

You are now ready to run your first AirRecorder session. In the Windows command
(DOS) window or Linux/Unix Shell terminal window, please type:
java -jar AirRecorder-<version>-release.jar <controller>

Please note that <controller> is the IP address or hostname of the controller 
you would like to run the session against.

As the session begins, you will be prompted for the username, password and 
enable password to be used to login into the controller (if you have 
"enable bypass" activated on the controller, just hit RETURN when prompted for
enable password).

A successful session would produce an output similar to:
 AirRecorder (c)2011-2012 Thomas Bastian, Aruba Networks
 Username: admin
 Password:
 Enable password:
 No enable password set, assuming enable mode when connected
 A new log file will be created every: 100 Mbytes
 Recording to file: air-recorder-192.168.0.196-20120410-184051-00.log
 Connecting to controller with hostname: 192.168.0.196, protocol: ssh, port: 22,
 username: admin
 Processing command: [show ap active] at interval of 0 seconds
 Running command: [show ap active] once
 All commands processed. Recording now. Interrupt with CTRL-C
 All commands completed. Exiting

At the end of the session, a new file should have been created:
air-recorder-192.168.0.196-20120410-184051-00.log

Please use your favourite editor to look at the contents recorded.


5. UNATTENDED USE
-----------------

AirRecorder can read the username, password and enable password for login into
the controller: 
- from the command line: -u <username> -p <password> -e <enable password>
  i.e.:
  java -jar AirRecorder-<version>-release.jar -u admin -p admin -e enable <controller>
  
- from a file named either "<controller>" or "<controller>.txt" argument 
  provided (i.e. in the above case, a file named: "192.168.0.196" or 
  "192.168.0.196.txt"). In this case, the file should contain the username,
  password and enable password each on a separate line in the file. If
  "enable bypass" is enabled on the controller, leave the third line blank.


6. WORKING WITH COMMANDS
------------------------

AirRecorder can read commands from any file. Please use the command line 
argument:
-c <command file>
to specify an alternate commands file to be used.

The commands file syntax is as follows:
- one command specification per line
- lines starting with # are skipped

- a command specification takes the form: [<trigger>;]<schedule>,<command>
  i.e.: 0,show ap active

<trigger> is an optional field and can be omitted. For more information on
triggers please read further in section TRIGGERS.

<schedule> is further broken down as:
  <interval>[;<execution count>[;<cycle interval>[;<cycle count>]]]

<interval> is the interval in *SECONDS* between consecutive executions. A value 
of zero will run the command once. Please be cautious when selecting the 
interval since smaller values may impact controller performance.

<execution count> is the optional number of times the command will be executed.
When unspecified the command will repeat for ever. Otherwise the command will
be executed the specified amount *PER* cycle. Note that if <cycle interval> is 
not specified, the command will be executed <execution count> number of times, 
then never again.

<cycle interval> is the optional interval between the start of repeating cycles. 
of running the command at every interval. If this is omitted, the command will
be executed just <execution count> times.

<cycle count> is the optional number of times to run the cycles.

<command> is the command string that is being sent to the controller. The string
is sent as is to the controller with the exception of placeholder and variable
processing.

Both interval and cycle interval are expressed in seconds. However, adding the
m or h suffix will provide values in minutes and hours respectively.

Examples:
 0,show ap active: will run the command "show ap active" once.
 1;1,show ap active: will run the command “show ap active” just once, i.e. 
                     “one shot”
 1m,show ap active: will run the command "show ap active" every minute.
 1m;2,show ap active: will run the command "show ap active" twice spaced by one
                      minute.
 1m;2;1h,show ap active: will run the command "show ap active" twice spaced by
                         one minute every hour.
 1m;2;1h;3,show ap active: will run the command "show ap active" twice spaced by
                           one minute every hour for three times.


7. OUTPUT FILES
---------------

AirRecorder records the CLI commands output to one or more files. Each file is
named after:
air-recorder-<controller>-<YYYYMMDD>-<HHMMSS>-<ID>.log

where:
- <controller> is the <controller> argument that was given.

- <YYYYMMDD> is the year, month, day when recording started.

- <HHMMSS> is the hours (24 hour), minutes and seconds when recording started.

- <ID> is a two digit number from 00 to 99.

By default, a new output file (with a different ID) will be created every
100 MB. You can change this default value by using the command line option:
--max-log-size <max-log-size in MB>

For convenience, AirRecorder supports the packing of multiple output files into 
a ZIP file. Please use following command line option to do so:
-z <output-zip-file>

For example:
java -jar AirRecorder-<version>-release.jar -z logfiles.zip
would produce an output similar to this:
 AirRecorder (c)2011-2012 Thomas Bastian, Aruba Networks
 Creating ZIP file: logfiles.zip ...
  + air-recorder-192.168.0.195-20120214-180521-00.log
  + air-recorder-192.168.0.195-20120410-183941-00.log
  + air-recorder-192.168.0.196-20120410-184030-00.log
  + air-recorder-192.168.0.196-20120410-184037-00.log
  + air-recorder-192.168.0.196-20120410-184051-00.log
  + air-recorder-192.168.0.196-20120410-185426-00.log
  + air-recorder-192.168.0.196-20120410-190107-00.log
 ---

Alternatively, one can specify a named log file with the --log-file option. In
that case, the resulting log file created will have the specified name and the
"-<ID>" appended.


8. CONTROLLER CONNECTION
------------------------

By default, AirRecorder will connect to the controller using SSH. However, you
can change this to the TELNET protocol using the command line option:
--protocol telnet

Furthermore, AirRecorder will use a default TCP port depending on the protocol
selected: SSH with port 22 and TELNET with port 23. You can select another port
by using the command line option:
--port <port>

By default, AirRecorder will wait for 60 seconds for CLI output. When a 
controller is busy or if you are working over a slow connection, you may want
to increase this to a higher value. Please use the command line option:
-t <timeout in seconds>

AirRecorder monitors the connection with the controller and will attempt to
reconnect if the connection is interrupted and/or showing excessive errors.

AirRecorder will keep recording until: 
  1) interrupted by CTRL-C
  2) no more commands are available for execution (i.e. only run once commands 
     in the commands file or no more cyclic commands)
  3) --quit-after is in use and the specified time has elapsed


9. PLACEHOLDERS
---------------

Placeholders are a convenient method to parametrise commands sent to a 
controller. By default, placeholders definitions are read from a file named:
"placeholders" or "placeholders.txt". You can change the default by using the 
command line option:
--placeholders <placeholders-file>
 
The placeholders file syntax is as follows:
- one placeholder specification per line

- a placeholder specification takes the form: 
  <placeholder>=<value1>,<value2>,...
  i.e.: apname=AP1,AP2

The placeholder can be referenced in the commands file by using the following
syntax: ${<placeholdername>}. For each placeholder value, AirRecorder will run
the specified command with the "${<placeholdername>}" string replaced with the
value.

For example, you could have an entry like this in your commands file:
0,show ap active ap-name ${apname}
and AirRecorder would run two commands once each:
show ap active ap-name AP1
show ap active ap-name AP2

NOTE: a placeholder definition can be spread over multiple lines by escaping the
      end of line with a \
      i.e.: apname3=\
	        AP6,\
	        AP7


10. VARIABLES
-------------

Variables offer an additional method of parametrising commands sent to a 
controller. Whereas placeholders use a predefined set of values, variables work 
with data that is fetched from the controller at runtime.

For example, to run a command for every AP on the controller, one would use the
variable: %{ap:name}. 

Here's the list of variables available:

%{ap:name} => all AP names as listed by "show ap active", column Name
%{ap:group} => all AP group names as listed by "show ap active", column Group
%{ap-group:name} => all AP group names as listed by "show ap-group", column Name
%{user:ip} => all IP addresses as listed by "show user-table", column IP
%{user:mac => all MAC addresses as listed by "show user-table", column MAC
%{user:name} => all user names as listed by "show user-table", column Name

%{time:hhmm} => outputs current controller time as hours:minutes (i.e. 10:42)
%{time:mmmdd} => outputs current controller time as month day (i.e. Jun 19)

%{jexl:return} => return values from a JEXL script execution. Please refer to
                  the section "SCRIPTING" for more information.

For example, you could have an entry like this in your commands file:
0,show ap active ap-name %{ap:name}
and AirRecorder would run the command once for each active AP name.


11. VARIABLES POST-PROCESSING
-----------------------------

The data set of a variable can be post-processed using processors. The general
syntax is for a processor is:
.processor([argument[,argument]])

Following processors are available:
- .upper(): convert variable values into upper case
- .lower(): convert variable values into lower case
- .droplast(): drop last value from variable values
- .include("include string"): retains only values that contains "include string"
- .exclude("exclude string"): retains only values that do not contain "exclude string"
- .match("regular expression"): retains only values that match the regular expression
- .differ("regular expression"): retains only values that do not match the regular expression
- .replace("regular expression", "replacement"): replaces every variable value 
                                                 matching regular expression 
                                                 with replacement
    
NOTE: processors can be chained
%{ap-group:name}.upper()
%{ap-group:name}.match("^DE.*").include("236")
%{time:hhmm}.replace(".$","")

NOTE/LIMITATION: when escaping in regular expressions, one needs to use double 
escape \ with \\: i.e. write \\S+.* for final expression: \S+.*


12. CUSTOM VARIABLES
--------------------

Custom variable definitions can be used in addition to pre-defined variables. 
The syntax is as follows:
#{<command>,<marker>,<column>[,<ttl>]}

where
- <command> is the command to run to fetch values, i.e. "show ap active"
- <marker> is the marker line to parse output, i.e. "Active AP Table"
- <column> is the name of the column to extract, i.e. "Name"
- <ttl> is the time-to-live of the variable content:
  -1: variable is loaded once (default)
  0: variable is loaded every time
  x: variable is loaded every x seconds

For example, you could have an entry like this in your commands file:
0,show ap debug radio-stats ap-name #{show ap database group APGROUP status up,,Name}
and AirRecorder would run the command once for each active AP in the AP group
named APGROUP.

NOTES: 
- the variable parser currently understands only the table based output commands
- marker and column are CASE sensitive
- marker can be left empty, i.e. #{<command>,,<column>[,<ttl>]}

EXCEPTIONS:
#{show clock,<format>,<N/A>,<always 0>} will output current controller time
  according to <format>. <column> is ignored and <ttl> is always 0.
  <format> patterns are described in 
    http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html


13. ADVANCED TOPICS
-------------------

Disabling local timing: by default AirRecorder will stop watch the execution of
every command processed using the AirRecorder host date and clock. The start and
stop times are recorded in the output log file.
Use the option: --no-local-timing to disable AirRecorder host based timing.

Enabling remote timing: use the option: --remote-timing to enable AirRecorder 
to issue a "show clock" on the controller before any command execution. The
start, stop and controller time are recorded in the output log file.

Post command delay: by default AirRecorder sends commands to the controller as
fast as possible. To slow down the pace at which commands are sent out, please
use the command line option:
--post-command-delay <post-command-delay in milliseconds>

Printing variables: please use the command line option:
--print-variable
to see how AirRecorder fetches and post-processes variable values.

Reporting interval: by default AirRecorder will print a status message about
its connection to the controller every 10 seconds. Use the command line option:
--reporting-interval to disable it (0) or change it to some other value in 
seconds (append m/h for minutes and hours).


14. NMEA
--------

NMEA compatible GPS devices are supported with AirRecorder. In order to record,
position, speed and altitude information into the log file, please use the option:
--nmea-port <COM port where GPS device is connected>
AirRecorder expects the NMEA data to be available on a serial communication port
(i.e. COM3).
There are a number of software available that make standard USB adapters provide
a virtual COM port (i.e. GpsGate).


15. TRIGGERS
------------

Triggers provide a way to condition the execution of selected commands in the
commands file.
A trigger is defined by using following syntax:
/<trigger name>=<path to JEXL script file>;

For example, the commands file line:
/trigger1=samples/message-logger.jexl;0,show ap active

defines a trigger name: "trigger1" that will execute the JEXL script file:
"samples/message-logger.jexl" AFTER it has executed the command "show ap active".

Multiple commands MAY use a given trigger to condition their execution. For 
example:
/trigger1;0,show clock
/trigger1;5;2,show datapath utilization

conditionally executes the:
- "show clock" command once
- "show datapath utilization" twice at an interval of 5 seconds
based on whether the trigger named "trigger1" has fired or not.

A trigger is considered as fired when the return value of the script execution
is either:
- the boolean value true.
- or a list of string values (can be empty*)
- or an array of string values (can be empty*)

JEXL scripts that return the boolean value false or null will not fire the trigger.
*When empty lists or arrays are returned the trigger will fire however the
resulting command list will be empty, hence no commands will be executed.

When a JEXL script returns a list or an array of values, these are made available
to all commands conditioned by the trigger by referencing the pre-defined variable
%{jexl:return}

For example:
/trigger1=myaplist.jexl;0,show clock
/trigger1;0,show ap active ap-name %{jexl:return}

Will execute the command "show ap active ap-name" for all values returned by the
JEXL script myaplist.jexl.

By default, trigger defining commands output is logged into the AirRecoder log
file (i.e. the result of the command preceding the execution of the JEXL script). 
One can disable this by using the option: --no-trigger-result
The result/s can still be logged to the AirRecoder log file on a case by case
basis using the airrecorder.log.write(result); script statement.


16. SCRIPTING
-------------

AirRecorder embeds a lightweight scripting engine named JEXL. For a full syntax
reference of valid JEXL scripts please see:
http://commons.apache.org/jexl/reference/syntax.html

When a JEXL script is invoked, a number of predefined variables are made available:

airrecorder.resultlist: boolean value
  When false, a single result is available, when true: a result list is available.
  
airrecoder.result: result of last execution
  NOT available when airrecorder.resultlist is true.
  
airrecorder.results: result list of last execution
  NOT available when airrecorder.resultlist is false.

airrecorder.log: for appending to AirRecorder log file
  airrecorder.log.write('hi'); - use for appending string to AirRecorder log file.
  airrecorder.log.write(airrecorder.result); - use for appending a result to 
                                               AirRecorder log file.
                                               
airrecorder.userlog: for appending freetext to the user log
  airrecorder.userlog.println('hi'); - use for appending string to user log file.
  
airrecorder.stdout: for appending freetext to standard output
  airrecorder.stdout.println('hi'); - use for appending string to standard out.
  
airrecorder.stderr: for appending freetext to standard error
  airrecorder.stderr.println('hi'); - use for appending string to standard error.

airrecorder.cli: CLI processor to send arbitrary commands to the CLI.
  airrecorder.cli.process('show clock'); - returns a result object.


By default, the userlog output is sent to standard error. By specifying the option:
--user-log <file>
one can record the output of user logs into the specified file.
 

17. CLI OUTPUT PARSING
----------------------

For parsing of tables produced by CLI output, AirRecorder provides a number of
helpers:

- com.arubanetworks.airrecorder.jexl.GenericTableParser
Use this table parser to extract data out of generic row/column tables such as
the one produced by "show datapath utilization"

Typical script usage is as follows:
var parser = new("com.arubanetworks.airrecorder.jexl.GenericTableParser", 
                 airrecorder.result.stdout, "\\|", -1, 5);
                 
The first argument is the string/text to parse.
The second argument is the column delimiter to use (regular expression).
The third argument is the offset of the table header line (use -1 to discard
header, in which case columns are named numbered starting from "1").
The firth argument is the offset of the table data line(s).
All offset are measured relative to the first non blank line in the input.

- com.arubanetworks.airrecorder.jexl.RowColumnTableParser
Use this table parser to extract data out of regular AOS tables such as the one
produced by "show ap active", "show user" etc...

Typical script usage is as follows:
var parser = new("com.arubanetworks.airrecorder.jexl.RowColumnTableParser", 
                 airrecorder.result.stdout, null);
                 
Once parsed, the data can be accessed using following accessors:

- com.arubanetworks.airrecorder.jexl.ParameterValueData
Use ParameterValueData accessor when mapping key/value table data.

Typical script usage is as follows:
var parameterValueData = new("com.arubanetworks.airrecorder.ParameterValueData", 
                             parser);
The first argument is parser to use for mapping (i.e. GenericTableParser).

Access key/value pairs using:
  .getData() method that returns a map of key/value pairs.

- com.arubanetworks.airrecorder.jexl.RowColumnData
Use RowColumnData accessor when mapping row/column table data.

Typical script usage is as follows:
var rowColumnData = new("com.arubanetworks.airrecorder.jexl.RowColumnData", 
                        parser);
The first argument is parser to use for mapping (i.e. GenericTableParser).

Access row/column data using:
  .getRowCount() that returns the number of rows.
  .getColumnCount() that returns the number of columns.
  .getDataAtRowColumn(int row, String columnKey) that return the data at row and
    column specified.
  .getDataAtColumn(String columnKey) that returns the entire column as a list of
    strings.
  .getDataAtColumns(String[] columnKeys that returns the entires columns as a 
    list of strings.
  .getDataAtRow(int row) that returns the entire row as a map of column/value
    pairs.
 

18. MESHOS SUPPORT
------------------

AirRecorder supports the Aruba MeshOS devices. When working with MeshOS devices,
please use option: --msr


19. INSTANT VC (IAP) SUPPORT
----------------------------

AirRecorder supports the Aruba Instant devices. When working with instant VC,
please use option: --instant

Instant defines some additional variables:
%{iap.aps:name} => all AP names as listed by "show aps", column Name
%{iap.aps:ip} => all AP IP addresses as listed by "show aps", column IP
%{iap.clients:ip} => all IP addresses as listed by "show clients", column IP
%{iap.clients:mac => all MAC addresses as listed by "show clients", column MAC
%{iap.clients:name} => all user names as listed by "show clients", column Name


A. OUTPUT FILE FORMAT
---------------------

Each log file produced by AirRecorder has the following format:

{
/////
.....
[message]*
}

That is the file begins with a first line containing: /////, followed by a 
second line containing .....
Then followed by zero or more message. A message is defined as:

{
/////
[///// <tag>: <value>]*
[
 ///// Section: <value>
 [<section content>]*
]
.....
}

That is a message begins with /////, followed by zero or more lines of the form:
///// <tag>: <value>, then followed by zero or more
///// Section: <value> segments
and finally terminated by
.....

Current implemented tags are:
- Message: describes the message type (usually RESULT)
- Status: when < 0 means that the execution has failed with this status code,
          when >= 0 total length of all content sections (in characters)
- LocalBeginTime: AirRecorder local time when command was submitted
- LocalEndTime: AirRecorder local time when command completed
- RemoteBeginTime: controller time when command was submitted
- RemoteEndTime: estimated controller time when command was completed
- RemoteRawTime: controller show clock output when command was submitted
- QueryTag: <querytag>=<value>
- Command: command submitted (optional)

NOTE: time is expressed in milliseconds since 1970-01-01 00:00:00 UTC.

Current implemented querytags are:
- airrecorder.command: originating command in commands file.
- airrecorder.data.source: data source that generated the command.
- airrecorder.group: unique identifier for a logical group of commands.
- airrecorder.cycle: cycle number.

Current implemented sections are:
- Stdout: standard output of controller.
- Stderr: error output of controller (present only if data available)
- Cause: exception message (present only if data available)


B. STANDARD OBJECTS
-------------------

airrecorder.result: class com.arubanetworks.aos.cli.Result
Fields:
  - int status - execution ok when >= 0, failed when < 0.
  - String stdout - command output.
  - long localBeginTime - local execution begin time in milliseconds.
  - long localEndTime - local execution end time in milliseconds.
  - long remoteBeginTime - remote execution begin time in milliseconds.
  - long remoteEndTime - remote execution end time in milliseconds.
  - String remoteRawTime - show clock output.
  - com.arubanetworks.aos.cli.Query query - query.
    Fields:
    	- String command - command sent.


Z. FEEDBACK
-----------

Feedback is welcome! Please send them to: tbastian@arubanetworks.com.
Contributions and acknowledgements: Aruba ACE/TAC teams.
